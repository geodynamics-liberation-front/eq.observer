#!/usr/bin/env python3
# vim: set fileencoding=utf-8 :

import crypt
import os
import re
import subprocess
import sys
import traceback


# TODO : mount without invoking the mount command
#import ctypes
#import ctypes.util
#libc = ctypes.CDLL(ctypes.util.find_library('c'), use_errno=True)
#libc.mount.argtypes = (ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_ulong, ctypes.c_char_p)
#
#def mount(source, target, fs, options=''):
#  ret = libc.mount(source, target, fs, 0, options)
#  if ret < 0:
#    errno = ctypes.get_errno()
#    raise OSError(errno, "Error mounting {} ({}) on {} with options '{}': {}".
#     format(source, fs, target, options, os.strerror(errno)))

mount_dir = "mnt"
boot_part = "boot"
rootfs_part = "rootfs"

wpa_supplicant="""
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
# Country code
# The ISO/IEC alpha2 country code for the country in which this device is
# currently operating.
country={country}
update_config=1
network={{
   ssid="{essid}"
   psk="{psk}"
}}
""".strip()

fdisk_cmd = ["fdisk","-l","{image_file}"]
fdisk_patterns = [
        ("size",r"^Units:.*? = (\d*) (\w*)", lambda m: int(m.group(1)*{'bytes':1}[m.group(2)])),
        ("partitions",r"({image_file}\d*)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\S+)\s+(\S+)\s+(.*)",lambda m: {"name":m.group(1),"sector_offset":int(m.group(2)),"sector_size":int(m.group(4))})
]

blkid_cmd=["blkid","--probe","--offset","{offset}","--size","{size}","--output","udev","{image}"]
blkid_patterns = [
        ("label","^ID_FS_LABEL=(.*)", lambda m: m.group(1)),
        ("fstype","^ID_FS_TYPE=(.*)", lambda m: m.group(1)) 
]

mount_cmd=["mount","-t","{fstype}","-o","loop,rw,offset={offset},sizelimit={size}","{image}","{mount_point}"]
umount_cmd=["umount","{mount_point}"]

essid_cmd=["iwgetid","-r"]

replace_pi_cmd = ["sed","-i",r"s/\bpi\b/eq/g","{file}"]
replace_pipw_cmd = ["sed","-i",r"s/\bpi:[^:]*:\b/eq:{hash}:/","{file}"] 

replace_hostname_cmd = ["sed","-i","s/raspberrypi/eqobserver/","{file}"]

#sudo ESSID=$ESSID su -c 'echo 
network_settings="/etc/NetworkManager/system-connections/{essid}.nmconnection"

def help(msg=None):
    if msg:
        print("%s\n"%msg)
    print( """
image-tool : Modifies the raspbian image for eq.Observer

Usage: image-tool [command...] [file]
   or: image-tool [file]
Arguments:
    command : A command or commands to execute, if absent "all"
    file    : Raspbian image file to modify

[command] is one of:
    mount   : mounts the specified image file
    wifi    : congifures the WiFi
    ssh     : enables ssh
    user    : configures the 'eq' user
    cleanup : cleans the working area
    all     : all of the above in order listed
""")
    sys.exit()



def match(patterns,lines):
    result = {}
    for line in lines:
        for pattern in patterns:
            name = pattern[0]
            p = pattern[1]
            l = pattern[2]
            m = re.match(p,line)
            if m:
                if name not in result:
                    result[name] = []
                result[name].append(l(m))
    return result

def cmd(args,format_args={}):
    print("DBG:"+str(format_args))
    args=[arg.format(**format_args) for arg in args]
    print("CMD: "+(" ".join(args)))
    result = subprocess.check_output(args,encoding='UTF-8')
    for line in result.split("\n"):
        print("---> "+line)
    return result

def parse_cmd(args,patterns=[],format_args={},update=False):
    patterns = [ tuple( ( i.format(**format_args) if hasattr(i,"format") and callable(getattr(i,"format")) else i for i in pattern ) )
            for pattern in patterns ]
    print(patterns)
    results = match(patterns,cmd(args,format_args).split("\n"))
    if update:
        format_args.update(results)
    return results

ini_section_re=re.compile("^\[(.*)\]$")
ini_comment_re=re.compile("^[;#]")
ini_keyvalue_re=re.compile("^([^[;#].*?)=(.*)$")
def read_ini(filename):
    ini={}
    section=ini
    with open(filename) as ini_file:
        for line in ini_file:
            match = ini_comment_re.match(line) or ini_keyvalue_re.match(line) or ini_section_re.match(line)
            if match:
                if match.re==ini_comment_re:
                    # ignore comment
                    pass
                elif match.re==ini_section_re:
                    section={}
                    ini[match.group(1)]=section
                elif match.re==ini_keyvalue_re:
                    section[match.group(1)]=match.group(2)
    return ini                    


def mount_image(image_file):
    mount_points=[]
    print("Mounting image %s"%image_file)
    fdisk_results = parse_cmd(fdisk_cmd, fdisk_patterns, {"image_file":image_file})
    sector_size = fdisk_results["size"][0]
    for part in fdisk_results["partitions"]:
        part["offset"]=sector_size*part["sector_offset"]
        part["size"]=sector_size*part["sector_size"]
        part["image"]=image_file
        # get the filesystem info
        parse_cmd(blkid_cmd, blkid_patterns, part, True)
        part["mount_point"]=os.path.join(mount_dir,part["label"][0])
        part["fstype"]=part["fstype"][0]
        # create the mount point
        os.mkdir(part["mount_point"])
        mount_points.append(part["mount_point"])
        #mount(image_file,part['name'],"loop,rw,offset={offset},sizelimit={size}".format(part))
        print(cmd(mount_cmd,part))
    return mount_points

def setup():
    os.mkdir(mount_dir)

def cleanup():
    if os.path.exists(mount_dir) and os.path.isdir(mount_dir):
        for child in os.listdir(mount_dir):
            mount_point=os.path.join(mount_dir,child)
            try:
                cmd(umount_cmd,{"mount_point":mount_point})
            except:
                print("Couldn't unmount {mount_point}".format(mount_point=mount_point))
            try:
                os.rmdir(mount_point)
            except:
                print("Couldn't remove {mount_point}".format(mount_point=mount_point))
        try:
            os.rmdir(mount_dir)
        except:
            print("Couldn't remove {mount_dir}".format(mount_dir=mount_dir))

def get_regulatory_domain():
    """
$ iw reg get
global
country US: DFS-FCC
	(2402 - 2472 @ 40), (N/A, 30), (N/A)
	(5170 - 5250 @ 80), (N/A, 23), (N/A), AUTO-BW
	(5250 - 5330 @ 80), (N/A, 23), (0 ms), DFS, AUTO-BW
	(5490 - 5730 @ 160), (N/A, 23), (0 ms), DFS
	(5735 - 5835 @ 80), (N/A, 30), (N/A)
	(57240 - 63720 @ 2160), (N/A, 40), (N/A)
"""
    return "US"

def get_essid():
    return cmd(essid_cmd).strip()

def get_network_settings(essid):
    return read_ini(network_settings.format(essid=essid))

def write_network_configuration(filename,**kwargs):
    print(wpa_supplicant.format(**kwargs))
    with open(filename,"w") as config:
        config.write(wpa_supplicant.format(**kwargs))
        config.flush()

def mount(vars,image_file):
    mount_points = mount_image(image_file)
    assert os.path.join(mount_dir,boot_part) in mount_points, "missing expected boot partition"
    assert os.path.join(mount_dir,rootfs_part) in mount_points, "missing expected boot partition"
    vars["mount_points"] = mount_points

def wifi(vars):
    vars['country'] = get_regulatory_domain()
    vars['essid'] = get_essid()
    vars['network_ini'] = get_network_settings(vars['essid'])
    vars['psk'] = vars['network_ini']['wifi-security']['psk']
    write_network_configuration(os.path.join(mount_dir,boot_part,"wpa_supplicant.conf"),**vars)

def ssh(vars):
    with open(os.path.join(mount_dir,boot_part,"ssh"),"w") as config:
        config.flush()

def user(vars):
    # update /etc/passwd
    cmd(replace_pi_cmd,{"file":os.path.join(mount_dir,rootfs_part,"etc","passwd")})
    # update /etc/group
    cmd(replace_pi_cmd,{"file":os.path.join(mount_dir,rootfs_part,"etc","group")})
    # update /etc/shadow
    cmd(replace_pipw_cmd,{
        "hash":crypt.crypt("observer")
            .replace("/",r"\/")
            .replace("$",r"\$"),
        "file":os.path.join(mount_dir,rootfs_part,"etc","shadow")
    })
    # update /etc/sudoer.d
    cmd(replace_pi_cmd,{"file":os.path.join(mount_dir,rootfs_part,"etc","sudoers.d","010_pi-nopasswd")})
    # update /home
    os.rename(
        os.path.join(mount_dir,rootfs_part,"home","pi"),
        os.path.join(mount_dir,rootfs_part,"home","eq"))

def hostname(vars):
    # update /etc/hostname
    cmd(replace_hostname_cmd,{"file":os.path.join(mount_dir,rootfs_part,"etc","hostname")})
    # update /etc/hosts
    cmd(replace_hostname_cmd,{"file":os.path.join(mount_dir,rootfs_part,"etc","hosts")})

if __name__=="__main__":
    args=sys.argv.copy()
    # get the name we were invoked with
    invoked=args.pop(0)
    vars = {}
    vars["args"]=args
    
    # if the last argument is a file, that's our image
    image_file=None
    if os.path.isfile(args[-1]):
        image_file=args.pop()
    commands = args.copy() if len(args)>0 else ["all"]
   
    # mount needs an image file
    if "mount" in commands and not image_file:
        help("Can't read image file "+image_file)

    vars["commands"]=commands
    try:
        while len(commands)>0:
            command = commands.pop(0)
            print(command)
            if command == "all":
                commands.extend( ["mount","wifi","ssh","hostname","user","cleanup"])
            elif command == "mount": 
                setup()
                mount(vars, image_file)
            elif command == "wifi": 
                wifi(vars)
            elif command == "ssh": 
                ssh(vars)
            elif command == "hostname":
                hostname(vars)
            elif command == "user": 
                user(vars)
            elif command == "cleanup": 
                cleanup()
            else:
                help("Unkown command {}".format(command))
    except:
        print("image-tool encountered an error")
        traceback.print_exc()

# ➜  pi-image git:(master) ✗ 
# ➜  pi-image git:(master) ✗ sudo mount -t ext4 -o loop,ro,offset=$((512 * 98304)),sizelimit=$((512 * 3424256)) 2019-04-08-raspbian-stretch-lite.img rootfs
